# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xRHsVZOfudqs-NP_MysXlAXNmn2-haIW
"""

##pip install bagpy

from mpl_toolkits import mplot3d
import bagpy
from bagpy import bagreader
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import math
from cmath import sqrt

#a=bagreader('/home/srinidhi/EECE5554/LAB4/src/analysis/bag files/data_going_in_circles-imu')
#e = a.message_by_topic('/imu')
#d=bagreader('/home/srinidhi/EECE5554/LAB4/src/analysis/bag files/2023-03-27-14-13-53.bag')
#f = d.message_by_topic('/gps')
#g=bagreader('/home/srinidhi/EECE5554/LAB4/src/analysis/bag files/2023-03-27-13-50-28.bag')
#h = g.message_by_topic('/imu')

from mpl_toolkits import mplot3d
import bagpy
from bagpy import bagreader
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import math
from cmath import sqrt

# a=bagreader('/content/drive/MyDrive/data_driving (1).bag')
# e = a.message_by_topic('/imu')
# d=bagreader('/content/drive/MyDrive/data_driving (1).bag')
# f = d.message_by_topic('/gps')
# g=bagreader('/content/drive/MyDrive/data_going_in_circles.bag')
# h = g.message_by_topic('/imu')

#a=bagreader('/content/drive/MyDrive/data_going_in_circles.bag')
#e = a.message_by_topic('/imu')

imucsv = pd.read_csv('/home/srinidhi/EECE5554/LAB4/src/analysis/bag files/data_driving-imu.csv')
imucir = pd.read_csv('/home/srinidhi/EECE5554/LAB4/src/analysis/bag files/data_going_in_circles-imu.csv')


mag_x = imucir['.mag_field.magnetic_field.x']
mag_y = imucir['.mag_field.magnetic_field.y']
mag_z = imucir['.mag_field.magnetic_field.z']

time_secs = imucir['.header.stamp.secs']
time_nsecs = imucir['.header.stamp.nsecs']
timec_imu = imucir['time']


plt.figure(figsize = (10,10))
plt.grid()
plt.scatter(mag_x, mag_y, marker="o",c='w',edgecolors='r')
#mycircle = plt.Circle((-0.1,0.32),0.228, fill = False)
#plt.gca().add_patch(mycircle) 
plt.gca().set_aspect("equal")
plt.show()

#HardIron _correction
x_max = max(mag_x)
y_max = max(mag_y)

x_min = min(mag_x)
y_min = min(mag_y)

alpha = (x_max+x_min)/2
beta = (y_max+y_min)/2

hiron_x = []
hiron_x.extend((mag_x-alpha))

hiron_y = []
hiron_y.extend((mag_y-beta))

plt.figure(figsize = (10,6))
plt.grid()
plt.scatter(hiron_x, hiron_y, marker=".",c='b',edgecolors='r')
plt.gca().set_aspect("equal")
plt.title("Hard_iron corrected plot of MagField(x vs y) ")
plt.xlabel("Hiron_x")
plt.ylabel("Hiron_y")
plt.show()

#SOFT-IRON
import numpy



rad = np.sqrt((hiron_x*2) + (hiron_y*2))
r = max(rad)
q = min(rad)

y1 = np.argmax(r)

theta = np.arcsin(y1/r)
theta_d = (theta*(180/np.pi))
#print(r)

#matrix generation
R = np.array([[np.cos(theta), np.sin(theta)],
     [-np.sin(theta), np.cos(theta)]])
b = np.array([[hiron_x, hiron_y]]) 
v1 = np.matmul(R, b)

# plt.figure(figsize = (10,6))
# plt.grid()
# plt.scatter(v1[:,0], v1[:,1], marker="o",c='w',edgecolors='g')
# mycircle2 = plt.Circle((0,0),0.23, fill = False)
# plt.gca().add_patch(mycircle2) 
# plt.gca().set_aspect("equal") 
# plt.show()  


#scale factor

sigma = r / q

print(f"sigma={sigma}")

# correction method

scale = np.array([[sigma, 0],[0, sigma]])
correct_mag_x1 = scale @ v1

theta1 = -theta

R_cal = np.array([[np.cos(theta1), np.sin(theta1)],[-np.sin(theta1), np.cos(theta1)]])
v_cal = np.matmul(R_cal, correct_mag_x1)


plt.figure(figsize = (12,10))

plt.grid()
plt.scatter(v_cal[:,0]/100, v_cal[:,1]/100,label='Corrected magnetic field', marker=".",c='r',edgecolors='b')
#mycircle4 = plt.Circle((0,0),0.173, fill = False)
#plt.gca().add_patch(mycircle4) 
plt.gca().set_aspect("equal") 
plt.scatter(mag_x, mag_y,label='Uncorrected magnetic field', marker="o",c='w',edgecolors='r')
plt.title("comparing Hard_iron and soft iron corrected plots of Magnetic-Field")
plt.xlabel(".Magnetic_field_x")
plt.ylabel(".Magnetic_field_y")
plt.legend(loc = "upper right")
plt.show()
print(numpy.size(timec_imu))
print(numpy.size(v_cal[:,0]))
plt.show()

from ctypes import sizeof

x = imucsv['.imu.orientation.x']
y = imucsv['.imu.orientation.y'] 
z = imucsv['.imu.orientation.z']
w = imucsv['.imu.orientation.w']
time_secs = imucsv['.header.stamp.secs']
time_nsecs = imucsv['.header.stamp.nsecs']
time = imucsv['time']

mag_x_d = x - alpha
mag_y_d = y - beta

mag_x_d = mag_x_d*sigma
mag_y_d = mag_y_d

def euler_from_quaternion(x, y, z, w):
        """
        Convert a quaternion into euler angles (roll, pitch, yaw)
        roll is rotation around x in radians (counterclockwise)
        pitch is rotation around y in radians (counterclockwise)
        yaw is rotation around z in radians (counterclockwise)
        """
        t0 = +2.0 * (w * x + y * z)
        t1 = +1.0 - 2.0 * (x * x + y * y)
        roll_x = np.arctan2(t0, t1)
        
        t2 = +2.0 * (w * y - z * x)
        pitch_y = np.arcsin(t2)
     
        t3 = +2.0 * (w * z + x * y)
        t4 = +1.0 - 2.0 * (y * y + z * z)
        yaw_z = np.arctan2(t3, t4)
        return roll_x, pitch_y, yaw_z # in radian

roll_x, pitch_y, yaw_z = euler_from_quaternion(x, y, z, w)

roll = roll_x    

pitch = pitch_y   

yaw = yaw_z      

m_x = mag_x_d 
m_y = mag_y_d
m_z1 = imucsv['.mag_field.magnetic_field.z']
m_z2 = m_z1.to_numpy()
m_z = np.reshape(m_z2, (1, 62745))

yaw_cal = np.arctan2(m_x, m_y)
yawcal1 = np.unwrap(yaw_cal)
yaw_cal = yaw_cal*(180/np.pi)

yaw_raw_cal = np.arctan2(x, y)
yaw_cal_raw_f = pd.Series(yaw_raw_cal)
yaw_cal_raw_f = yaw_cal_raw_f*(180/np.pi)

plt.figure(figsize = (16,8))

magyawcrcted=yaw_cal
plt.plot(magyawcrcted/10, label='corrected Magnetic_yaw')
magyawuncrcted=yaw_cal_raw_f
plt.plot(magyawuncrcted, label='raw Magnetic_yaw')
plt.title("Raw Magnetic Yaw vs Corrected Magnetic Yaw")
plt.xlabel("No of values")
plt.ylabel("Yaw (Degrees)")
plt.legend()
plt.show()

import scipy.integrate as integrate

time_secs = imucsv['.header.stamp.secs']
time_nsecs = np.double(imucsv['.header.stamp.nsecs'])
time_nsecs = time_nsecs/1000000000
time_imu = np.double(time_secs) + time_nsecs

angz=imucsv['.imu.angular_velocity.z']
gyro_int = integrate.cumtrapz(angz)
print(np.size(gyro_int))
plt.figure(figsize = (16,8))
plt.plot(gyro_int, label = 'Gyro_Yaw_rate')   
plt.plot(magyawcrcted, label = 'yaw_calibarated')
plt.legend()
plt.title('Angle comparision b/w  mag_yaw v/s ang_vel_yaw')
plt.xlabel('number of readings')    
plt.ylabel('Yaw')                                                                                                               
plt.show()
plt.plot(gyro_int, label = 'Gyro_Yaw_rate')   
plt.show()

plt.plot(magyawcrcted, label = 'yaw_calibarated')
plt.show()

plt.show()

from scipy.signal.filter_design import butter
from scipy import signal
import numpy

lpf = signal.filtfilt(*butter(3, 0.1, "lowpass", analog=False, fs = 40), magyawcrcted)

hpf = signal.filtfilt(*butter(3, 0.01, 'highpass', analog=False, fs = 40), gyro_int)
print(lpf)
print(lpf[0]/10+hpf[0]/10)
plt.figure(figsize = (16,8))
plt.plot(lpf, label='lpf yaw_cal')
plt.legend(loc = "upper right")
plt.xlabel('TIime in secs')

plt.ylabel('Yaw')

plt.plot(hpf, label = 'HPF Gyro_Yaw')
plt.legend(loc = "upper right")
plt.title('Lopass Filter for Magnetic Yaw and HighPass Filter for Gyro Yaw v/s Time')
plt.xlabel('TIime in secs')
plt.ylabel('Yaw')
plt.show()

plt.plot(lpf, label='lpf crcted_Magnetic_yaw')
plt.show()

plt.plot(hpf, label = 'HPF Gyro_Yaw')
plt.show()

alpha = 0.997

yaw_filtered=[]
yaw_filtered=np.append(yaw_filtered,0)
for i in range(62744):
  yaw_filtered=np.append(yaw_filtered,alpha*(yaw_filtered[i]+gyro_int[i]*0.025)+ (1-alpha)*(lpf[i]))

print(len(yaw_filtered))
print(np.shape(yaw_filtered))
print(yaw_filtered)


plt.figure(figsize = (16,8))
plt.plot(yaw_filtered/100, label='complimetary_filter_output')

plt.plot(yaw_z, label = 'IMU_yaw')
plt.legend(loc = "upper right")
plt.xlabel('TIime in secs')
plt.ylabel('Yaw')
plt.title('Original_yaw vs caliberated Yaw')
plt.show()

plt.figure(figsize = (16,8))
plt.plot(lpf, label='lpf yaw_cal')
plt.legend(loc = "upper right")
plt.xlabel('TIime in secs')
plt.ylabel('Yaw')
plt.plot(hpf, label = 'HPF Gyro_Yaw')
plt.plot(yaw_filtered/10, label='complimetary_filter_output')

plt.legend(loc = "upper right")
plt.xlabel('Time in secs')
plt.ylabel('Yaw')
plt.title('Lopass Filter for Magnetic Yaw v/s HighPass Filter for Gyro Yaw v/s  complimentary_Yaw')
plt.show()

import numpy as np
time = imucsv['.header.stamp.secs']
raw_val = imucsv['.imu.linear_acceleration.x']
x = np.mean(raw_val)
leniaraccl = raw_val - x

plt.figure(figsize = (15,8))
plt.plot(raw_val)
plt.plot(leniaraccl)
print(len(leniaraccl[1:]))
diff = []
for i in range(62744):
  diff = np.append(diff,(leniaraccl[i+1] - leniaraccl[i])/(time[i+1]-time[i]))
print(diff)
print(len(diff))
final = leniaraccl[1:] - diff                #to remove jerk

Forward_velocity_adjusted_x = integrate.cumtrapz(final, initial=0)
Forward_velocity_raw = integrate.cumtrapz(leniaraccl, initial=0)

plt.figure(figsize = (15,8))
plt.plot(Forward_velocity_adjusted_x/2)
plt.plot(Forward_velocity_raw)
plt.xlabel('No of values')
plt.ylabel('Velocity (m/sec)')
plt.title('Forward Velocity vs Forward Velocity raw')
plt.show()

import numpy as np
time = imucsv['.header.stamp.nsecs']
raw_val = imucsv['.imu.linear_acceleration.y']
y = np.mean(raw_val)
leniaraccl = raw_val - y

plt.figure(figsize = (15,8))
plt.plot(raw_val)
plt.plot(leniaraccl)
print(len(leniaraccl))
diff = []
for i in range(62744):
  diff = np.append(diff, (leniaraccl[i+1] - leniaraccl[i])/(time[i+1]-time[i]))
print(diff)
final = leniaraccl[1:] - diff                #to remove jerk
Forward_velocity_adjusted_y = integrate.cumtrapz(final, initial=0)
Forward_velocity_raw = integrate.cumtrapz(leniaraccl, initial=0)

plt.figure(figsize = (15,8))
plt.plot(Forward_velocity_adjusted_y/2)
plt.plot(Forward_velocity_raw)
plt.xlabel('No of values')
plt.ylabel('Velocity (m/sec)')
plt.title('Forward Velocity vs Forward Velocity raw')
plt.show()

gpscsv = pd.read_csv('/home/srinidhi/EECE5554/LAB4/src/analysis/bag files/data_driving-gps.csv')
y=imucsv['.imu.linear_acceleration.x']
time_imu=imucsv['.header.stamp.secs']+imucsv['.header.stamp.nsecs']*100000000
time_gps = gpscsv['time']


x = y-np.mean(y)


diff=[]
for i in range(62744):
  diff = np.append(diff,(x[i+1]-x[i])/(time_imu[i+1]-time_imu[i]))

acc=[]
for i in range(62745):
  if(x[i]>0):
    acc= np.append(acc,x[i]) 
  else:
    acc=np.append(acc,0)

plt.plot(acc)
plt.show()
vel = integrate.cumtrapz(acc, initial=0)
plt.plot(vel)
plt.show()

time=gpscsv['.Header.stamp.secs']

Ue = gpscsv['.UTM_easting']
Un = gpscsv['.UTM_northing']

dist=[]
vel=[]
for i in range(1568):
  dist = np.append(dist,math.sqrt(((Un[i+1]-Un[i])**2)+(Ue[i+1]-Ue[i])**2))
print(len(dist))

gps_vel=dist/time[1:]
plt.figure(figsize = (15,8))
plt.plot(time[1:], gps_vel/10)
plt.show()

plt.figure(figsize = (15,8))
time_gp = gpscsv['time']
#plt.plot(time_gp, Forward_velocity_adjusted/1300)
plt.plot(time_gp[1:], gps_vel*6000)

plt.figure(figsize = (15,8))
time_gp = gpscsv['time']

#plt.plot(time, Forward_velocity_raw)
plt.plot(time_gp[1:], gps_vel*2000000)

Intigrated_forward_vel = integrate.cumtrapz(Forward_velocity_adjusted_x, initial=0)
int_gps_vel = integrate.cumtrapz(dist, initial=0)
print(Intigrated_forward_vel, Forward_velocity_adjusted_x)

plt.figure(figsize = (12,8))
plt.plot(time_imu[1:],Intigrated_forward_vel*10)

plt.plot(time_gp[1:],int_gps_vel*100000)
plt.show()
# int_gps_vel_gp = integrate.cumtrapz(gps_vel, initial=0)
# print(Intigrated_forward_vel, Forward_velocity_adjusted)
# plt.plot(time[1:], Intigrated_forward_vel)
# plt.show()
# plt.plot(time_gp[1:], int_gps_vel_gp*1100)
# plt.show()

# plt.plot(time[1:], Intigrated_forward_vel)
# plt.plot(time_gp[1:], int_gps_vel_gp/100)
# plt.show()



gpscsv = pd.read_csv('/home/srinidhi/EECE5554/LAB4/src/analysis/bag files/data_going_in_circles-gps.csv')

time=gpscsv['.Header.stamp.secs']

Ue=gpscsv['.UTM_easting']
plt.plot(time,Ue)
plt.show()
print(Ue)

veloe=[]
# velon=[]

# for j in range(431):
#   velon=numpy.append(velon,(Un[i+1]-Un[i])/(time[i+1]-time[i]))
# print(velon)

for i in range(431):
  veloe=numpy.append(veloe,(Ue[i+1]-Ue[i])/(time[i+1]-time[i]))
print(veloe)
veloe=veloe-s.mean(veloe)

# plt.plot(velon)
# plt.show()

plt.plot(veloe)
plt.show()

import math
gpscsv = pd.read_csv('/home/srinidhi/EECE5554/LAB4/src/analysis/bag files/data_driving-gps.csv')

time1=gpscsv['.Header.stamp.secs']

Un=gpscsv['.UTM_northing']

Ue=gpscsv['.UTM_easting']
dist=[]
vel=[]
for i in range(431):
  dist=numpy.append(dist,math.sqrt(((Un[i+1]-Un[i])**2)+(Ue[i+1]-Ue[i])**2))
print(len(dist))
# for j in range(430):
#   vel=numpy.append(vel,((dist[j+1]-dist[j])/(time[j+1]-time[j])))  
vel=dist/time1[1:]
# plt.plot(dist)

# plt.show()
plt.plot(time1[1:]/50,vel*1000)
plt.show()
# plt.plot(time[1:]*10 ,accc/100)
# plt.show()

import math
gpscsv = pd.read_csv('/home/srinidhi/EECE5554/LAB4/src/analysis/bag files/data_driving-gps.csv')

time1=gpscsv['.header.stamp.secs']

Un=gpscsv['.UTM_northing']

Ue=gpscsv['.UTM_easting']

lat=gpscsv['.Latitude']

lon=gpscsv['.Longitude']


plt.plot(Un,Ue)
plt.show()

plt.plot(lat,lon)
plt.show()

from PyAstronomy import pyasl
import string
import numpy
import scipy
import statistics as s
imucsv = pd.read_csv('/home/srinidhi/EECE5554/LAB4/src/analysis/bag files/data_driving-imu.csv')
accex=imucsv['.imu.linear_acceleration.x']
timeimu=imucsv['.header.stamp.secs']+imucsv['.header.stamp.nsecs']*10e-9

velocity_x=scipy.integrate.cumtrapz(timeimu,accex)
plt.plot(velocity_x)
plt.show()

dis_x=scipy.integrate.cumtrapz(timeimu[1:],Forward_velocity_adjusted_x)
plt.plot(dis_x)
plt.show()

accey=imucsv['.imu.linear_acceleration.y']

velocity_y=scipy.integrate.cumtrapz(timeimu,accey)
plt.plot(velocity_y)

plt.show()


dis_y=scipy.integrate.cumtrapz(timeimu[1:],Forward_velocity_adjusted_y)
plt.plot(dis_y)
plt.show()

plt.plot(dis_x,dis_y)
plt.show()

from PyAstronomy import pyasl
import string
import numpy
import scipy
import statistics as s
imucsv = pd.read_csv('/home/srinidhi/EECE5554/LAB4/src/analysis/bag files/data_driving-imu.csv')
accex=imucsv['.imu.linear_acceleration.x']
timeimu=imucsv['.header.stamp.secs']+imucsv['.header.stamp.nsecs']*10e-9

xdouble=accex
xsingle=scipy.integrate.cumtrapz(time_imu,xdouble)

plt.plot(xsingle)
plt.show()
angz=imucsv['.imu.angular_velocity.z']

accey1=angz[1:]*xsingle

t=imucsv['.header.stamp.secs']
plt.plot(t[1:],accey1)
plt.show()
accey=accey/3
plt.plot(t,accey)
plt.show()

accey=imucsv['.imu.linear_acceleration.y']
plt.plot(t,accey*(10**16))
plt.plot(t[1:],accey1)
plt.show()
ve=[]
vn=[]
for i in range(62745):
  ve1=numpy.append(ve,(Forward_velocity_adjusted_x[i]*np.cos(yaw_filtered[i]*180/math.pi)))
  vn1=numpy.append(vn,(-Forward_velocity_adjusted_x[i]*np.sin(yaw_filtered[i]*180/math.pi)))
  ve2=numpy.append(ve,(Forward_velocity_adjusted_x[i]*np.cos(yaw_filtered[i]*180/math.pi)))
  vn2=numpy.append(vn,(Forward_velocity_adjusted_x[i]*np.sin(yaw_filtered[i]*180/math.pi)))

ve=ve1+ve2
vn=vn1+vn2

print(numpy.shape(ve))
print(numpy.shape(vn))


xe=scipy.integrate.cumtrapz(time_imu[1:],ve)
xn=scipy.integrate.cumtrapz(time_imu[1:],vn)

# print(xe)
# print(xn)

plt.plot(xe,xn)

def wrapToPi(x):
    xwrap = np.remainder(x, 2 * np.pi)
    mask = np.abs(xwrap) > np.pi
    xwrap[mask] -= 2 * np.pi * np.sign(xwrap[mask])
    mask1 = x < 0
    mask2 = np.remainder(x, np.pi) == 0
    mask3 = np.remainder(x, 2 * np.pi) != 0
    xwrap[mask1 & mask2 & mask3] -= 2 * np.pi
    return xwrap

import scipy.integrate as si


fv = Forward_velocity_adjusted_x

aclre= np.tile(fv,(2,1))
print(aclre)
print(np.shape(aclre))
rotation = -108*(math.pi)/180
print(np.shape(yaw_filtered))
rot=0
for i in range(62745):
  rv = np.array([[np.cos(yaw_filtered[i]+rot), np.sin(yaw_filtered[i]+rot)],
      [-np.sin(yaw_filtered[i]+rot), np.cos(yaw_filtered[i]+rot)]])
print(np.shape(rv))

 
velocity = np.matmul(rv,aclre)
ve=velocity[0]
vn=velocity[1]

# print(aclmul)
plt.plot(ve)
plt.plot(vn)
plt.show()

xe=scipy.integrate.cumtrapz(ve,initial=0)
xn=scipy.integrate.cumtrapz(vn,initial=0)
plt.plot(xn)
plt.plot(xe)

plt.show()

import numpy
fv = Forward_velocity_adjusted_x

aclre= np.tile(fv,(2,1))
print(aclre)


rotation = -108*(math.pi)/180
#print(np.shape(yaw_filtered))
rot=0
# rv=[]


R_cal = np.array([[np.cos(theta1), np.sin(theta1)],
      [-np.sin(theta1), np.cos(theta1)]])

print(R_cal)
print(np.shape(R_cal))

for i in range(62745):
  #rv=np.array([[np.cos(theta1), np.sin(theta1)],[-np.sin(theta1), np.cos(theta1)]])
  rv=np.array([[np.cos(yaw_filtered[i]),-np.sin(yaw_filtered[i])],[np.sin(yaw_filtered[i]), np.cos(yaw_filtered[i])]])

print(len(rv))
print(np.shape(rv))
print(rv)


velocity = rv*aclre

ve=velocity[0]
vn=velocity[1]

plt.plot(ve)
plt.plot(vn)
plt.show()

xe=integrate.cumtrapz(ve,initial=0)
xn=integrate.cumtrapz(vn,initial=0)
plt.plot(xn, xe)


plt.show()

fv = Forward_velocity_adjusted_x
print(len(yaw_filtered), len(Forward_velocity_adjusted_x))
mgh = imucsv['.mag_field.magnetic_field.x']
mgh1 = yaw_filtered

rot = -108*(math.pi)/180

unit1 = np.cos(mgh1[1:]+rot)*fv
unit2 = -np.sin(mgh1[1:]+rot)*fv
unit3 = np.cos(mgh1[1:]+rot)*fv
unit4 = np.sin(mgh1[1:]+rot)*fv
ve = unit1+unit2
vn = unit3+unit4

xe=integrate.cumtrapz(ve)
xn=integrate.cumtrapz(vn)
xe1=np.unwrap(np.unwrap(xe))
xn1=np.unwrap(np.unwrap(xn))

plt.plot(xe/10000, xn/10000)
plt.show()
#plt.plot(utmeast, utmnorth)
plt.show()
